name: "Create Package"
on:
  workflow_call:
    inputs:
      SFDX_ENV:
        description: "Environent variables to be set for sf commands"
        required: false
        type: string
    outputs:
      packageId:
        value: ${{ jobs.create-package.outputs.packageId }}
jobs:
  create-package:
    name: Create Package
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      packageId: ${{ steps.package-version-create.outputs.packageId }}
      betaVersionNumber: ${{ steps.package-version-create.outputs.betaVersionNumber }}
      codeCoverage: ${{ steps.package-version-create.outputs.codeCoverage }}
    steps:
      # Checkout source code
      - name: Checkout source code
        uses: actions/checkout@v4

      # Install SF
      - name: Install SF
        uses: navikt/crm-workflows-base/.github/actions/installSF@master

      # Authorize Prod
      - name: Authorize PROD
        uses: navikt/crm-workflows-base/.github/actions/authenticateOrg@master
        with:
          auth-url: ${{ secrets.CRM_PROD_SFDX_URL }}
          alias: prod
          setDefaultUsername: true
          setDefaultDevhubUsername: true

      # Delete unpackagable and scratch-org folder
      - name: Create package version
        id: package-version-create
        shell: bash
        run: |
          set -euo pipefail
      
          # Helper to sanitize SF CLI JSON on stdout (drops ANSI, BOM, preamble)
          clean_json() {
            sed -r 's/\x1B\[[0-9;]*[A-Za-z]//g' \
            | sed '1s/^\xEF\xBB\xBF//' \
            | awk '
                BEGIN{buf="";depth=0;found=0}
                {
                  if(!found){
                    i=index($0,"{"); if(i==0) next; line=substr($0,i); found=1;
                  } else { line=$0 }
                  for(j=1;j<=length(line);j++){
                    c=substr(line,j,1); buf=buf c;
                    if(c=="{") depth++; else if(c=="}") depth--;
                  }
                  if(found && depth==0){ print buf; exit }
                }
                END{ if(found && depth==0) exit 0; else exit 1 }
              '
          }
      
          # Pick the FIRST package dir that actually declares "package"
          PKG_ALIAS=$(
            jq -r '
              [ .packageDirectories[]? | select(.package != null) | .package ][0] // empty
            ' sfdx-project.json
          )
      
          if [[ -z "$PKG_ALIAS" ]]; then
            echo "::error title=No package alias found::No entry with a \"package\" field in packageDirectories."
            jq -r '.packageDirectories' sfdx-project.json || true
            exit 1
          fi
      
          echo "Using package alias: $PKG_ALIAS"
      
          # Create the version (set installation key for the version)
          # 1) Capture raw stdout/stderr to files
          sf package version create \
            --target-dev-hub prod \
            --definition-file config/project-scratch-def.json \
            --package "$PKG_ALIAS" \
            --installation-key "${{ secrets.CRM_PACKAGE_KEY }}" \
            --wait 120 \
            --code-coverage \
            --json \
            1> raw_create_stdout.log \
            2> create_warn.log
          
          # 2) Try to extract a clean JSON object from stdout
          if ! clean_json < raw_create_stdout.log > output.json; then
            echo "::error title=No JSON from sf::sf did not emit valid JSON on stdout (or JSON was truncated)."
            echo "::group::sf stdout"
            sed -n '1,200p' raw_create_stdout.log || true
            echo "::endgroup::"
            echo "::group::sf stderr/warnings"
            sed -n '1,200p' create_warn.log || true
            echo "::endgroup::"
            exit 1
          fi
          
          # 3) Now parse and validate the JSON like before
          STATUS=$(jq -r '.status' output.json)
          if [[ "$STATUS" != "0" ]]; then
            echo "::error title=sf package version create failed::$(jq -r '.message // .name // "Unknown error"' output.json)"
            echo "::group::output.json"
            cat output.json
            echo "::endgroup::"
            echo "::group::sf stderr/warnings"
            sed -n '1,200p' create_warn.log || true
            echo "::endgroup::"
            exit 125
          fi
          
          packageId=$(jq -r '.result.SubscriberPackageVersionId' output.json)
          versionNumber=$(jq -r '.result.VersionNumber' output.json)
          betaVersionNumber=$(jq -r '.result.VersionNumber | split(".")[3]' output.json)
          
          if [[ -z "$packageId" || -z "$versionNumber" ]]; then
            echo "::error title=Missing fields::No packageId/versionNumber in output.json"
            echo "::group::output.json"
            cat output.json
            echo "::endgroup::"
            exit 1
          fi
          
          # Get code coverage (capture, sanitize, parse)
          sf package version report --package "$packageId" --json \
            1> raw_report_stdout.log \
            2> report_warn.log
          
          codeCoverage=$(
            clean_json < raw_report_stdout.log \
            | jq -r '.result.CodeCoverage.apexCodeCoveragePercentage // empty'
          )
          
          echo "packageId=$packageId" >> "$GITHUB_OUTPUT"
          echo "betaVersionNumber=$betaVersionNumber" >> "$GITHUB_OUTPUT"
          echo "codeCoverage=${codeCoverage:-}" >> "$GITHUB_OUTPUT"
          
          echo
          echo "Package ID: $packageId"
          echo "Version:    $versionNumber  (beta build: $betaVersionNumber)"
          echo "Coverage:   ${codeCoverage:-n/a}%"


      - name: Upload diagnostics (always)
        if: always()            # runs on success or failure
        uses: actions/upload-artifact@v4
        with:
          name: package-create-diagnostics
          path: |
            raw_create_stdout.log
            create_warn.log
            raw_report_stdout.log
            report_warn.log
            output.json
          if-no-files-found: warn
          retention-days: 14


  validate-in-sit:
    name: Validate install in SIT Sandbox
    needs: [create-package]
    uses: navikt/crm-workflows-base/.github/workflows/deployPackage.yml@master
    with:
      packageId: ${{ needs.create-package.outputs.packageId }}
      org: sit
      unpackagable: ./force-app/unpackagable-with-auto-deploy
      SFDX_ENV: ${{ inputs.SFDX_ENV }}
    secrets: inherit

  create-release:
    name: Create release
    needs: [create-package, validate-in-sit]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      # Checkout source code
      - name: Checkout source code
        uses: actions/checkout@v4

      # set release variables
      - name: Set release fields
        id: release-fields
        run: |
          versionNumber=$(cat sfdx-project.json | jq '.packageDirectories | map(select(.package != null))[0].versionNumber' -r | sed 's/.\{5\}$//')
          betaVersionNumber=${{ needs.create-package.outputs.betaVersionNumber }}
          echo "tagName=v$(echo $versionNumber)-beta$(echo $betaVersionNumber)" >> $GITHUB_OUTPUT
          echo "releaseName=$(echo $versionNumber)-beta$(echo $betaVersionNumber)" >> $GITHUB_OUTPUT
          echo "bodyVersion=$(echo $versionNumber).$(echo $betaVersionNumber)" >> $GITHUB_OUTPUT
          echo "bodyPackage=${{ needs.create-package.outputs.packageId }}" >> $GITHUB_OUTPUT
          echo "packageCreation=✅ Package Creation" >> $GITHUB_OUTPUT
          if [ ${{ needs.validate-in-sit.outputs.successfullyInstalledPackage }} == "true" ]; then
            echo "integrationInstallation=✅ Package Installation (Integration Sandbox)" >> $GITHUB_OUTPUT
          else
            echo "integrationInstallation=❌ Package Installation (Integration Sandbox)" >> $GITHUB_OUTPUT
          fi
      # Generate changelog from commits
      - name: Generate changelog
        id: changelog
        uses: metcalfc/changelog-generator@v4.1.0
        with:
          mytoken: ${{ secrets.GITHUB_TOKEN }}

      # create github release
      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          tag_name: ${{ steps.release-fields.outputs.tagName }}
          name: ${{ steps.release-fields.outputs.releaseName }}
          body: |
            **Version**: ${{ steps.release-fields.outputs.bodyVersion }}
            **Package ID**: ${{ steps.release-fields.outputs.bodyPackage }}
            **Code Coverage**: ${{ needs.create-package.outputs.codeCoverage }}%
            **Author**: ${{ github.actor }}
            ${{ steps.release-fields.outputs.packageCreation }}
            ${{ steps.release-fields.outputs.integrationInstallation }}
            ## Changelog
            ${{ steps.changelog.outputs.changelog }}
          draft: false
          prerelease: true
